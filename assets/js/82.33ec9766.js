(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{516:function(e,t,a){"use strict";a.r(t);var r=a(4),o=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"large-scale-processing"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#large-scale-processing"}},[e._v("#")]),e._v(" Large scale processing")]),e._v(" "),t("p",[e._v("Processing of larger areas up to global scale is one of the more challenging tasks in earth observation,\nbut certainly one that this platform wants to address. This page describes some best practices based on the example\nof "),t("a",{attrs:{href:"https://github.com/openEOPlatform/openeo-classification",target:"_blank",rel:"noopener noreferrer"}},[e._v("processing a croptype map for all 27 countries in the European Union"),t("OutboundLink")],1),e._v(". We do encourage you to get in touch with backend providers about your\nspecific case, as not every workflow is the same, and some advance planning may be needed to ensure that you get sufficient\nprocessing resources.")]),e._v(" "),t("figure",[t("img",{attrs:{src:"https://raw.githubusercontent.com/openEOPlatform/openeo-classification/60aa7a869f9000b1795afe2c9dde0d7977bcdbc6/docs/full_europe.png",alt:"Crop type map for EU27"}}),e._v(" "),t("figcaption",[e._v("EU27 croptype map, processed on openEO platform")])]),e._v(" "),t("p",[e._v("The approach desribed here is based on local files to track the production. This is a low-cost approach that does not require\nspecial IT knowledge, but comes with some risks such as loosing your local files. A more robust approach for production-grade projects\nwould typically rely on some sort of database or STAC catalog service to monitor processing. Such a setup is however quite similar in many aspects.")]),e._v(" "),t("p",[e._v("The basic strategy for processing large areas is to split it up into smaller areas, usually according to a regular tile grid.\nSplitting reduces the size of the area that needs to be processed by one batch job, and avoids running into all kinds of limitations.\nFor instance, when processing in a specific projection, you anyway have to stay within the bounds of that projection. Also the output\nfile size of a job often becomes impractical when working over huge areas. Or you will hit bottlenecks in the backend implementation that\ndo not occur for normally sized jobs. Also, when a smaller job fails or requires reprocessing, the cost will be smaller.")]),e._v(" "),t("h2",{attrs:{id:"relevant-openeo-features"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#relevant-openeo-features"}},[e._v("#")]),e._v(" Relevant openEO features")]),e._v(" "),t("p",[e._v("We want to highlight a few key elements that made us choose openEO for large scale processing:")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://openeo.org/documentation/1.0/developers/backends/performance.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Performance & scalability"),t("OutboundLink")],1)]),e._v(" "),t("li",[e._v("STAC metadata is generated for you, making your output dissemination ready without becoming a metadata expert yourself.")]),e._v(" "),t("li",[e._v("Where relevant FAIR principles are taken into account automatically, such as providing provenance information.")]),e._v(" "),t("li",[e._v("Cloud optimized file formats are generated by default.")]),e._v(" "),t("li",[e._v("Processing can be distributed over multiple backends.")])]),e._v(" "),t("h2",{attrs:{id:"preparation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#preparation"}},[e._v("#")]),e._v(" Preparation")]),e._v(" "),t("p",[e._v("The idea is that we first create and persist the list of tiles to produce, with all attributes required to produce that\nspecific tile. This gives us a very good visual overview of the processing that will be performed.")]),e._v(" "),t("p",[e._v("Having job parameters in a file is also useful for debugging afterwards. Determining parameters at runtime means you don't\nhave absolute certainty over the value of a specific argument, as there may be bugs in your code.")]),e._v(" "),t("h2",{attrs:{id:"prepare-tiling-grid"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#prepare-tiling-grid"}},[e._v("#")]),e._v(" Prepare tiling grid")]),e._v(" "),t("p",[e._v("The choice of tiling grid depends on your preferred projection system, which depends on your area of interest.\nFor Europe, the EPSG:3035 projection can be used, while for global processing you may want to work with different projections according\nto UTM zones.")]),e._v(" "),t("p",[e._v("The size of tiles in your grid is also important, and often ranges from 20km to 100km. For relatively light workflows, a 100km grid can work well,\nwhile for more demanding cases, a 20km grid is better. In our example, we choose to work with 20km tiles because the workflow was quite demanding. A smaller\ntile size can also result in less unneeded processing when your target area has an irregular shape, like most countries and continents.")]),e._v(" "),t("p",[e._v("A couple of basic grids can be found here:\n"),t("a",{attrs:{href:"https://artifactory.vgt.vito.be/webapp/#/artifacts/browse/tree/General/auxdata-public/grids",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://artifactory.vgt.vito.be/webapp/#/artifacts/browse/tree/General/auxdata-public/grids"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("The images below illustrate the overlap in the UTM grids versus a regular LAEA grid.")]),e._v(" "),t("table",[t("thead",[t("tr",[t("th",{staticStyle:{"text-align":"center"}},[e._v("UTM 100km")]),e._v(" "),t("th",{staticStyle:{"text-align":"center"}},[e._v("LAEA 100km")])])]),e._v(" "),t("tbody",[t("tr",[t("td",{staticStyle:{"text-align":"center"}},[t("img",{attrs:{src:"https://user-images.githubusercontent.com/5937096/231963581-1c51a512-c240-4d23-b557-30a3577c9027.png",width:"400",height:"300"}})]),e._v(" "),t("td",{staticStyle:{"text-align":"center"}},[t("img",{attrs:{src:"https://user-images.githubusercontent.com/5937096/231963750-562b921c-7b5b-4ec1-86ca-cf1fd75e625d.png",width:"400",height:"300"}})])])])]),e._v(" "),t("p",[e._v("A grid can be masked based on the countries we want to load, the following script shows an example:")]),e._v(" "),t("div",{staticClass:"language-python extra-class"},[t("pre",{pre:!0,attrs:{class:"language-python"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("import")]),e._v(" geopandas "),t("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("as")]),e._v(" gpd\neurope "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" gpd"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("read_file"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("gpd"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("datasets"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("get_path"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"naturalearth_lowres"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\neurope "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" europe"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("europe"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("continent"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("==")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Europe"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\ncountries "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" europe"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("europe"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("name"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("isin"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("EU27"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\ndf "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" gpd"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("read_file"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[e._v('"https://artifactory.vgt.vito.be/auxdata-public/grids/LAEA-20km.gpkg"')]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("mask"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("countries"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),t("h2",{attrs:{id:"prepare-job-attributes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#prepare-job-attributes"}},[e._v("#")]),e._v(" Prepare job attributes")]),e._v(" "),t("p",[e._v("Next to the tiling grid, we recommend to also determine other properties required by your processing jobs up front. This allows you to properly\nreview those properties before starting to process. Examples include simple things like a job title or tile specific processing parameters, but also an\nattribute to determine processing order.")]),e._v(" "),t("p",[e._v("In this step, you may also want to make sure to already determine the correct tile extent in the coordinate system of your tile grid.\nProviding exact coordinates in the right projection is necessary to ensure pixel-perfect alignment of your tiles.")]),e._v(" "),t("h2",{attrs:{id:"tuning-your-processing-job"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tuning-your-processing-job"}},[e._v("#")]),e._v(" Tuning your processing job")]),e._v(" "),t("p",[e._v("Before kicking off large processing, you want to be very sure that the correct output is generated, and that you have sufficient credits and resources\navailable to finish your job in time. This can be done by simply running various jobs, and using the statistics reported in the metadata to determine average parameters. (The map production section below shows a way to collect these parameters in a CSV.)")]),e._v(" "),t("p",[e._v("For instance, for the case of processing the EU27 croptype map, consisting of ~11000 20km tiles, we made the following calculations op front:")]),e._v(" "),t("ul",[t("li",[e._v("Average runtime was 30 minutes, which means that it would take ~15 days of continous processing with 15 parallel jobs.")]),e._v(" "),t("li",[e._v("Average cost was below 100 credits, so we would be able to process with a budget of 1100000 credits.")])]),e._v(" "),t("p",[e._v("To achieve these numbers, we did have to optimize batch job settings and also the overall workflow to reduce resource usage!")]),e._v(" "),t("p",[e._v("A common bottleneck to parallellization is the memory consumption, and it can be useful to know the maximum memory allocation on a single machine in\nyour backend of choice. For instance, in a cloud environment with 16GB per machine and 4 cpu's, using slightly less than 4GB per worker is efficient as you can fit 4 parallel workers on a single VM, while requiring 6GB would fit only 2 workers and leave about 4GB unused.")]),e._v(" "),t("p",[e._v("In our example, we used the Geotrellis backends, which has "),t("RouterLink",{attrs:{to:"/federation/#customizing-batch-job-resources-on-terrascope"}},[e._v("these execution options")]),e._v(".")],1),e._v(" "),t("h2",{attrs:{id:"starting-map-production"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#starting-map-production"}},[e._v("#")]),e._v(" Starting map production")]),e._v(" "),t("p",[e._v("The openEO Python client provides a useful tool to run multiple processing jobs in multiple backends:")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://open-eo.github.io/openeo-python-client/cookbook/job_manager.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://open-eo.github.io/openeo-python-client/cookbook/job_manager.html"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("This class takes a GeoJSON corresponding to your tile grid and job properties per tiles, and triggers a function provided by you whenever a new\njob needs to be created. You can configure multiple backends, and set the number of parallel jobs per backend.")]),e._v(" "),t("p",[e._v("This class also takes care of error handling, and can be considered more resilient compared to writing a simple loop yourself.")]),e._v(" "),t("p",[e._v("A full example of how we use this can be found "),t("a",{attrs:{href:"https://github.com/openEOPlatform/openeo-classification/blob/main/src/openeo_classification/scripts/cropmap_eu27.py",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),t("OutboundLink")],1),e._v(".")]),e._v(" "),t("p",[e._v("This script uses a CSV file to track your jobs, and whenever it is interrupted it can simply resume from that CSV file, making it tolerant to failure.")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://user-images.githubusercontent.com/5937096/231968590-f0f0b415-453c-4ab7-9502-82eab795a84e.png",alt:"Tracking jobs by CSV"}})]),e._v(" "),t("h2",{attrs:{id:"errors-during-production"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#errors-during-production"}},[e._v("#")]),e._v(" Errors during production")]),e._v(" "),t("p",[e._v("It is expected to see jobs failing during production, which can be considered normal as long as the failure rate is not too high. We advice to quickly inspect error logs, and if no obvious reason for failure is found, a simple retry might be sufficient. In other cases it may be needed to increase memory.\nWe also see a limited number of cases where for instance issues in the underlying product archive cause failures or artifacts. These are harder to resolve, and may require interaction with the backend to resove!")])])}),[],!1,null,null,null);t.default=o.exports}}]);